local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Configuration
local UNLIMITED_JUMP_POWER = 50
local ORIGINAL_JUMP_POWER = 50
local TOTAL_PLOTS = 30

-- Anti-Detect Configuration
local ANTI_DETECT = {
	-- Randomize all timings by this percentage (0.0 to 1.0)
	TIMING_VARIANCE = 0.3,
	
	-- Add random micro-pauses to simulate human behavior
	MICRO_PAUSE_ENABLED = true,
	MICRO_PAUSE_CHANCE = 0.15,
	MICRO_PAUSE_MIN = 0.05,
	MICRO_PAUSE_MAX = 0.2,
	
	-- Randomize teleport positions slightly
	POSITION_JITTER_ENABLED = true,
	POSITION_JITTER_RANGE = 2,
	
	-- Vary claim attempts
	CLAIM_ATTEMPTS_MIN = 2,
	CLAIM_ATTEMPTS_MAX = 4,
	
	-- Add occasional "idle" periods
	IDLE_CHANCE = 0.08,
	IDLE_MIN = 1,
	IDLE_MAX = 3,
	
	-- Randomize delay between claims (seconds)
	CLAIM_DELAY_MIN = 19,
	CLAIM_DELAY_MAX = 24,
	
	-- Randomize upgrade delay
	UPGRADE_DELAY_MIN = 1.8,
	UPGRADE_DELAY_MAX = 2.5
}

-- State
local unlimitedJumpEnabled = false
local originalJumpPower = ORIGINAL_JUMP_POWER
local autoCelestialEnabled = false
local celestialConnection
local autoUpgradeEnabled = false
local upgradeConnections = {}
local autoClaimEnabled = false
local claimConnections = {}
local claimPaused = false

-- Anti-Detect Random Number Generator (seeded with unique value)
local antiDetectRandom = Random.new(tick() * os.clock() * math.random(1, 10000))

-- Anti-Detect Functions
local function getRandomizedDelay(baseDelay, variancePercent)
	variancePercent = variancePercent or ANTI_DETECT.TIMING_VARIANCE
	local variance = baseDelay * variancePercent
	return baseDelay + antiDetectRandom:NextNumber(-variance, variance)
end

local function addMicroPause()
	if ANTI_DETECT.MICRO_PAUSE_ENABLED and antiDetectRandom:NextNumber(0, 1) < ANTI_DETECT.MICRO_PAUSE_CHANCE then
		wait(antiDetectRandom:NextNumber(ANTI_DETECT.MICRO_PAUSE_MIN, ANTI_DETECT.MICRO_PAUSE_MAX))
	end
end

local function addIdlePause()
	if antiDetectRandom:NextNumber(0, 1) < ANTI_DETECT.IDLE_CHANCE then
		wait(antiDetectRandom:NextNumber(ANTI_DETECT.IDLE_MIN, ANTI_DETECT.IDLE_MAX))
	end
end

local function getJitteredPosition(basePosition)
	if not ANTI_DETECT.POSITION_JITTER_ENABLED then
		return basePosition
	end
	
	local jitter = ANTI_DETECT.POSITION_JITTER_RANGE
	return basePosition + Vector3.new(
		antiDetectRandom:NextNumber(-jitter, jitter),
		0,
		antiDetectRandom:NextNumber(-jitter, jitter)
	)
end

local function getRandomClaimAttempts()
	return antiDetectRandom:NextInteger(ANTI_DETECT.CLAIM_ATTEMPTS_MIN, ANTI_DETECT.CLAIM_ATTEMPTS_MAX)
end

-- Detect device type
local function isMobile()
	return UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
end

-- Create UI with modern, responsive design
local function createUI()
	local ScreenGui = Instance.new("ScreenGui")
	ScreenGui.Name = "ModernUI"
	ScreenGui.ResetOnSpawn = false
	ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	ScreenGui.IgnoreGuiInset = true

	-- Determine sizes based on device
	local mobile = isMobile()
	local containerWidth = mobile and 340 or 460
	local containerHeight = mobile and 480 or 460
	local sidebarWidth = mobile and 100 or 130
	local buttonHeight = 46
	local spacing = 10

	-- Open Button (shows when UI is closed)
	local OpenButton = Instance.new("TextButton")
	OpenButton.Name = "OpenButton"
	OpenButton.Size = UDim2.new(0, 46, 0, 46)
	OpenButton.Position = UDim2.new(0, 10, 0.5, -23)
	OpenButton.AnchorPoint = Vector2.new(0, 0.5)
	OpenButton.BackgroundColor3 = Color3.fromRGB(30, 32, 42)
	OpenButton.BorderSizePixel = 0
	OpenButton.Text = "â˜°"
	OpenButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	OpenButton.TextSize = 20
	OpenButton.Font = Enum.Font.GothamBold
	OpenButton.Visible = false
	OpenButton.ZIndex = 100
	OpenButton.Parent = ScreenGui

	local OpenCorner = Instance.new("UICorner")
	OpenCorner.CornerRadius = UDim.new(0, 10)
	OpenCorner.Parent = OpenButton

	local OpenStroke = Instance.new("UIStroke")
	OpenStroke.Color = Color3.fromRGB(60, 63, 78)
	OpenStroke.Thickness = 1.5
	OpenStroke.Parent = OpenButton

	-- Main Container
	local Container = Instance.new("Frame")
	Container.Name = "Container"
	Container.Size = UDim2.new(0, containerWidth, 0, containerHeight)
	Container.Position = UDim2.new(0.5, 0, 0.5, 0)
	Container.AnchorPoint = Vector2.new(0.5, 0.5)
	Container.BackgroundColor3 = Color3.fromRGB(30, 32, 42)
	Container.BorderSizePixel = 0
	Container.Parent = ScreenGui

	local ContainerCorner = Instance.new("UICorner")
	ContainerCorner.CornerRadius = UDim.new(0, 16)
	ContainerCorner.Parent = Container

	local ContainerStroke = Instance.new("UIStroke")
	ContainerStroke.Color = Color3.fromRGB(50, 53, 68)
	ContainerStroke.Thickness = 2
	ContainerStroke.Parent = Container

	-- Close Button (X)
	local CloseButton = Instance.new("TextButton")
	CloseButton.Name = "CloseButton"
	CloseButton.Size = UDim2.new(0, 32, 0, 32)
	CloseButton.Position = UDim2.new(1, -42, 0, 10)
	CloseButton.BackgroundColor3 = Color3.fromRGB(235, 64, 52)
	CloseButton.BorderSizePixel = 0
	CloseButton.Text = "X"
	CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	CloseButton.TextSize = 16
	CloseButton.Font = Enum.Font.GothamBold
	CloseButton.ZIndex = 10
	CloseButton.Parent = Container

	local CloseCorner = Instance.new("UICorner")
	CloseCorner.CornerRadius = UDim.new(0, 8)
	CloseCorner.Parent = CloseButton

	-- Hover effect for close button
	CloseButton.MouseEnter:Connect(function()
		game:GetService("TweenService"):Create(CloseButton, TweenInfo.new(0.2), {
			BackgroundColor3 = Color3.fromRGB(255, 74, 62)
		}):Play()
	end)

	CloseButton.MouseLeave:Connect(function()
		game:GetService("TweenService"):Create(CloseButton, TweenInfo.new(0.2), {
			BackgroundColor3 = Color3.fromRGB(235, 64, 52)
		}):Play()
	end)

	-- Sidebar
	local Sidebar = Instance.new("Frame")
	Sidebar.Name = "Sidebar"
	Sidebar.Size = UDim2.new(0, sidebarWidth, 1, 0)
	Sidebar.Position = UDim2.new(0, 0, 0, 0)
	Sidebar.BackgroundColor3 = Color3.fromRGB(24, 26, 35)
	Sidebar.BorderSizePixel = 0
	Sidebar.Parent = Container

	local SidebarCorner = Instance.new("UICorner")
	SidebarCorner.CornerRadius = UDim.new(0, 16)
	SidebarCorner.Parent = Sidebar

	-- Creator Title
	local CreatorTitle = Instance.new("TextLabel")
	CreatorTitle.Name = "CreatorTitle"
	CreatorTitle.Size = UDim2.new(1, -16, 0, 50)
	CreatorTitle.Position = UDim2.new(0, 8, 0, 12)
	CreatorTitle.BackgroundTransparency = 1
	CreatorTitle.Text = "Made by\nRoms"
	CreatorTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
	CreatorTitle.TextSize = mobile and 14 or 16
	CreatorTitle.Font = Enum.Font.GothamBold
	CreatorTitle.TextXAlignment = Enum.TextXAlignment.Center
	CreatorTitle.TextYAlignment = Enum.TextYAlignment.Center
	CreatorTitle.Parent = Sidebar

	local TitleGradient = Instance.new("UIGradient")
	TitleGradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(147, 112, 219)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 149, 237))
	}
	TitleGradient.Rotation = 45
	TitleGradient.Parent = CreatorTitle

	-- Home Button
	local HomeButton = Instance.new("TextButton")
	HomeButton.Name = "HomeButton"
	HomeButton.Size = UDim2.new(1, -16, 0, 42)
	HomeButton.Position = UDim2.new(0, 8, 0, 75)
	HomeButton.BackgroundColor3 = Color3.fromRGB(50, 115, 220)
	HomeButton.BorderSizePixel = 0
	HomeButton.Text = "Home"
	HomeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	HomeButton.TextSize = mobile and 12 or 14
	HomeButton.Font = Enum.Font.GothamBold
	HomeButton.Parent = Sidebar

	local HomeCorner = Instance.new("UICorner")
	HomeCorner.CornerRadius = UDim.new(0, 10)
	HomeCorner.Parent = HomeButton

	-- Main Content Area with ScrollingFrame for mobile compatibility
	local ContentArea = Instance.new("ScrollingFrame")
	ContentArea.Name = "ContentArea"
	ContentArea.Size = UDim2.new(1, -(sidebarWidth + 20), 1, -30)
	ContentArea.Position = UDim2.new(0, sidebarWidth + 10, 0, 15)
	ContentArea.BackgroundTransparency = 1
	ContentArea.BorderSizePixel = 0
	ContentArea.ScrollBarThickness = 4
	ContentArea.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 120)
	ContentArea.CanvasSize = UDim2.new(0, 0, 0, 0)
	ContentArea.AutomaticCanvasSize = Enum.AutomaticSize.Y
	ContentArea.Parent = Container

	-- Title Section
	local TitleSection = Instance.new("Frame")
	TitleSection.Name = "TitleSection"
	TitleSection.Size = UDim2.new(1, 0, 0, 54)
	TitleSection.Position = UDim2.new(0, 0, 0, 35)
	TitleSection.BackgroundColor3 = Color3.fromRGB(40, 43, 56)
	TitleSection.BorderSizePixel = 0
	TitleSection.Parent = ContentArea

	local TitleCorner = Instance.new("UICorner")
	TitleCorner.CornerRadius = UDim.new(0, 12)
	TitleCorner.Parent = TitleSection

	local TitleText = Instance.new("TextLabel")
	TitleText.Name = "TitleText"
	TitleText.Size = UDim2.new(1, -24, 1, 0)
	TitleText.Position = UDim2.new(0, 12, 0, 0)
	TitleText.BackgroundTransparency = 1
	TitleText.Text = "Game Features"
	TitleText.TextColor3 = Color3.fromRGB(230, 230, 240)
	TitleText.TextSize = mobile and 14 or 16
	TitleText.Font = Enum.Font.GothamBold
	TitleText.TextXAlignment = Enum.TextXAlignment.Left
	TitleText.Parent = TitleSection

	-- Feature creator function
	local yOffset = 99

	local function createFeature(name, iconColor, yPos, hasButton)
		local Feature = Instance.new("Frame")
		Feature.Name = name .. "Toggle"
		Feature.Size = UDim2.new(1, 0, 0, buttonHeight)
		Feature.Position = UDim2.new(0, 0, 0, yPos)
		Feature.BackgroundColor3 = Color3.fromRGB(40, 43, 56)
		Feature.BorderSizePixel = 0
		Feature.Parent = ContentArea

		local FeatureCorner = Instance.new("UICorner")
		FeatureCorner.CornerRadius = UDim.new(0, 12)
		FeatureCorner.Parent = Feature

		local FeatureStroke = Instance.new("UIStroke")
		FeatureStroke.Color = Color3.fromRGB(50, 53, 68)
		FeatureStroke.Thickness = 1
		FeatureStroke.Transparency = 0.7
		FeatureStroke.Parent = Feature

		local FeatureLabel = Instance.new("TextLabel")
		FeatureLabel.Name = "Label"
		FeatureLabel.Size = UDim2.new(1, -110, 1, 0)
		FeatureLabel.Position = UDim2.new(0, 12, 0, 0)
		FeatureLabel.BackgroundTransparency = 1
		FeatureLabel.Text = name
		FeatureLabel.TextColor3 = Color3.fromRGB(210, 210, 220)
		FeatureLabel.TextSize = mobile and 12 or 14
		FeatureLabel.Font = Enum.Font.GothamMedium
		FeatureLabel.TextXAlignment = Enum.TextXAlignment.Left
		FeatureLabel.Parent = Feature

		if hasButton == "toggle" then
			local ToggleButton = Instance.new("TextButton")
			ToggleButton.Name = "ToggleButton"
			ToggleButton.Size = UDim2.new(0, 48, 0, 26)
			ToggleButton.Position = UDim2.new(1, -58, 0.5, -13)
			ToggleButton.BackgroundColor3 = Color3.fromRGB(55, 58, 73)
			ToggleButton.BorderSizePixel = 0
			ToggleButton.Text = ""
			ToggleButton.Parent = Feature

			local ToggleCorner = Instance.new("UICorner")
			ToggleCorner.CornerRadius = UDim.new(1, 0)
			ToggleCorner.Parent = ToggleButton

			local ToggleCircle = Instance.new("Frame")
			ToggleCircle.Name = "Circle"
			ToggleCircle.Size = UDim2.new(0, 20, 0, 20)
			ToggleCircle.Position = UDim2.new(0, 3, 0.5, -10)
			ToggleCircle.BackgroundColor3 = Color3.fromRGB(150, 150, 160)
			ToggleCircle.BorderSizePixel = 0
			ToggleCircle.Parent = ToggleButton

			local CircleCorner = Instance.new("UICorner")
			CircleCorner.CornerRadius = UDim.new(1, 0)
			CircleCorner.Parent = ToggleCircle

			return Feature, ToggleButton, ToggleCircle
		elseif hasButton == "button" then
			local ActionButton = Instance.new("TextButton")
			ActionButton.Name = "ActionButton"
			ActionButton.Size = UDim2.new(0, 38, 0, 38)
			ActionButton.Position = UDim2.new(1, -48, 0.5, -19)
			ActionButton.BackgroundColor3 = iconColor
			ActionButton.BorderSizePixel = 0
			ActionButton.Text = ">"
			ActionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
			ActionButton.TextSize = 14
			ActionButton.Font = Enum.Font.GothamBold
			ActionButton.Parent = Feature

			local ActionCorner = Instance.new("UICorner")
			ActionCorner.CornerRadius = UDim.new(0, 10)
			ActionCorner.Parent = ActionButton

			return Feature, ActionButton
		end

		return Feature
	end

	-- Create features
	local JumpFeature, JumpToggleButton, JumpToggleCircle = createFeature(
		"Unlimited Jump", 
		Color3.fromRGB(100, 200, 255), 
		yOffset, 
		"toggle"
	)
	yOffset = yOffset + buttonHeight + spacing

	local TeleportFeature, TeleportButton = createFeature(
		"Teleport to Spawn", 
		Color3.fromRGB(80, 180, 255), 
		yOffset, 
		"button"
	)
	yOffset = yOffset + buttonHeight + spacing

	local CelestialFeature, CelestialToggleButton, CelestialToggleCircle = createFeature(
		"Auto Celestial", 
		Color3.fromRGB(255, 215, 0), 
		yOffset, 
		"toggle"
	)
	yOffset = yOffset + buttonHeight + spacing

	local ClaimFeature, ClaimToggleButton, ClaimToggleCircle = createFeature(
		"Auto Claim Cash", 
		Color3.fromRGB(50, 255, 100), 
		yOffset, 
		"toggle"
	)
	yOffset = yOffset + buttonHeight + spacing

	local UpgradeFeature, UpgradeToggleButton, UpgradeToggleCircle = createFeature(
		"Auto Upgrade", 
		Color3.fromRGB(147, 112, 219), 
		yOffset, 
		"toggle"
	)

	-- Make draggable (optimized for both PC and mobile)
	local dragging = false
	local dragInput, dragStart, startPos

	local function updateDrag(input)
		local delta = input.Position - dragStart
		Container.Position = UDim2.new(
			startPos.X.Scale,
			startPos.X.Offset + delta.X,
			startPos.Y.Scale,
			startPos.Y.Offset + delta.Y
		)
	end

	Container.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = Container.Position

			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)

	Container.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if dragging and input == dragInput then
			updateDrag(input)
		end
	end)

	ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

	return ScreenGui, JumpToggleButton, JumpToggleCircle, TeleportButton, CelestialToggleButton, CelestialToggleCircle, ClaimToggleButton, ClaimToggleCircle, UpgradeToggleButton, UpgradeToggleCircle, CloseButton, OpenButton, Container
end

-- Function to animate toggle with smooth transitions
local function animateToggle(toggleButton, circle, enabled, activeColor)
	local TweenService = game:GetService("TweenService")
	local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)

	if enabled then
		TweenService:Create(circle, tweenInfo, {
			Position = UDim2.new(1, -23, 0.5, -10)
		}):Play()

		TweenService:Create(toggleButton, tweenInfo, {
			BackgroundColor3 = activeColor
		}):Play()

		TweenService:Create(circle, tweenInfo, {
			BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		}):Play()
	else
		TweenService:Create(circle, tweenInfo, {
			Position = UDim2.new(0, 3, 0.5, -10)
		}):Play()

		TweenService:Create(toggleButton, tweenInfo, {
			BackgroundColor3 = Color3.fromRGB(55, 58, 73)
		}):Play()

		TweenService:Create(circle, tweenInfo, {
			BackgroundColor3 = Color3.fromRGB(150, 150, 160)
		}):Play()
	end
end

-- Function to enable/disable unlimited jump
local function setUnlimitedJump(enabled)
	unlimitedJumpEnabled = enabled

	local character = LocalPlayer.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			if enabled then
				originalJumpPower = humanoid.JumpPower
				humanoid.JumpPower = UNLIMITED_JUMP_POWER
				humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
			else
				humanoid.JumpPower = originalJumpPower
			end
		end
	end
end

-- Handle jump input for unlimited jumping
local jumpConnection
local function setupUnlimitedJumping()
	if jumpConnection then
		jumpConnection:Disconnect()
	end

	jumpConnection = UserInputService.JumpRequest:Connect(function()
		if unlimitedJumpEnabled then
			local character = LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				end
			end
		end
	end)
end

-- Function to teleport to spawn
local function teleportToSpawn()
	local character = LocalPlayer.Character
	if not character then
		return
	end

	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then
		return
	end

	local spawnLocation = game.Workspace:FindFirstChild("SpawnLocation")

	if spawnLocation then
		local targetPos = getJitteredPosition(spawnLocation.CFrame.Position + Vector3.new(0, 3, 0))
		humanoidRootPart.CFrame = CFrame.new(targetPos)
		addMicroPause()
	end
end

-- Function to find celestial brainrot ProximityPrompt
local function findCelestialPrompt()
	local gameFolder = game.Workspace:FindFirstChild("GameFolder")
	if not gameFolder then
		return nil, nil
	end

	local brainrots = gameFolder:FindFirstChild("Brainrots")
	if not brainrots then
		return nil, nil
	end

	local celestialFolder = brainrots:FindFirstChild("Celestial")
	if not celestialFolder then
		return nil, nil
	end

	for _, descendant in ipairs(celestialFolder:GetDescendants()) do
		if descendant:IsA("ProximityPrompt") then
			local parentPart = descendant.Parent
			return descendant, parentPart
		end
	end

	return nil, nil
end

-- Function to grab celestial (automatic sequence with anti-detect)
local function grabCelestial()
	local character = LocalPlayer.Character
	if not character then 
		return 
	end

	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then 
		return 
	end

	local proximityPrompt, promptPart = findCelestialPrompt()

	if not proximityPrompt or not promptPart then
		return
	end

	-- Anti-detect: Add slight delay before teleporting
	wait(getRandomizedDelay(0.3, 0.4))
	
	-- Teleport with position jitter
	local targetPos = getJitteredPosition(promptPart.CFrame.Position + Vector3.new(0, 3, 0))
	humanoidRootPart.CFrame = CFrame.new(targetPos)

	-- Anti-detect: Randomized wait before interacting
	wait(getRandomizedDelay(0.5, 0.3))
	addMicroPause()

	if proximityPrompt.Enabled then
		fireproximityprompt(proximityPrompt)

		wait(getRandomizedDelay(0.2, 0.2))
		
		local events = ReplicatedStorage:FindFirstChild("Events")
		if events then
			local tutorialEvent = events:FindFirstChild("Tutorial")
			if tutorialEvent then
				tutorialEvent:FireServer("Grab")
			end
		end
	end

	-- Anti-detect: Randomized wait before returning
	wait(getRandomizedDelay(1.5, 0.3))
	addIdlePause()

	teleportToSpawn()
end

-- Function to setup auto celestial
local function setupAutoCelestial()
	if celestialConnection then
		celestialConnection:Disconnect()
		celestialConnection = nil
	end

	if not autoCelestialEnabled then
		return
	end

	local events = ReplicatedStorage:FindFirstChild("Events")
	if not events then
		return
	end

	local notificationEvent = events:FindFirstChild("Notification")
	if not notificationEvent then
		return
	end

	celestialConnection = notificationEvent.OnClientEvent:Connect(function(message, data)
		if autoCelestialEnabled and message == "A Celestial has spawned!" then
			if autoClaimEnabled then
				claimPaused = true
			end
			
			-- Anti-detect: Random delay before starting
			wait(getRandomizedDelay(1, 0.5))
			grabCelestial()
			
			if autoClaimEnabled then
				claimPaused = false
			end
		end
	end)
end

-- Function to claim cash from player's plot by teleporting to claim parts (with anti-detect)
local function claimAllPlots()
	if not autoClaimEnabled or claimPaused then return end

	local character = LocalPlayer.Character
	if not character then return end

	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return end

	local playerPlot = LocalPlayer:GetAttribute("Plot")
	if not playerPlot then 
		return 
	end

	local gameFolder = game.Workspace:FindFirstChild("GameFolder")
	if not gameFolder then return end

	local plots = gameFolder:FindFirstChild("Plots")
	if not plots then return end

	local plot = plots:FindFirstChild(tostring(playerPlot))
	if not plot then return end

	local places = plot:FindFirstChild("Places")
	if not places then return end

	local claimedCount = 0

	for slotNum = 1, 30 do
		if not autoClaimEnabled or claimPaused then 
			break 
		end

		local slot = places:FindFirstChild(tostring(slotNum))
		if slot then
			local claimPart = slot:FindFirstChild("Claim")

			if claimPart and claimPart:IsA("BasePart") and claimPart.Transparency ~= 1 then
				-- Save original claim part properties
				local originalCFrame = claimPart.CFrame
				local originalAnchored = claimPart.Anchored
				local originalCanCollide = claimPart.CanCollide
				
				-- Anchor the claim part BEFORE teleporting
				claimPart.Anchored = true
				claimPart.CanCollide = false
				
				-- Anti-detect: Small randomized delay
				wait(getRandomizedDelay(0.1, 0.3))
				addMicroPause()
				
				-- Teleport player with position jitter
				local baseTargetPos = originalCFrame.Position + Vector3.new(0, 3, 0)
				local jitteredPos = getJitteredPosition(baseTargetPos)
				humanoidRootPart.CFrame = CFrame.new(jitteredPos)
				
				-- Anti-detect: Randomized wait
				wait(antiDetectRandom:NextNumber(0.15, 0.35))
				
				-- Anti-detect: Variable number of touch attempts
				local touchAttempts = getRandomClaimAttempts()
				for i = 1, touchAttempts do
					firetouchinterest(humanoidRootPart, claimPart, 0)
					wait(getRandomizedDelay(0.01, 0.5))
					firetouchinterest(humanoidRootPart, claimPart, 1)
					wait(getRandomizedDelay(0.01, 0.5))
				end

				claimedCount = claimedCount + 1
				
				-- Restore claim part to original state
				claimPart.CFrame = originalCFrame
				claimPart.Anchored = originalAnchored
				claimPart.CanCollide = originalCanCollide
				
				-- Anti-detect: Randomized delay between claims with occasional idle pause
				local claimDelay = antiDetectRandom:NextNumber(
					ANTI_DETECT.CLAIM_DELAY_MIN, 
					ANTI_DETECT.CLAIM_DELAY_MAX
				)
				wait(claimDelay)
				addIdlePause()
			end
		end
	end

	return claimedCount
end

-- Function to setup auto claim cash with continuous loop
local function setupAutoClaimCash()
	for _, connection in pairs(claimConnections) do
		if connection and connection.Disconnect then
			connection:Disconnect()
		end
	end
	claimConnections = {}

	if not autoClaimEnabled then
		return
	end

	local loopRunning = true
	table.insert(claimConnections, {
		Disconnect = function()
			loopRunning = false
		end
	})

	coroutine.wrap(function()
		while loopRunning and autoClaimEnabled do
			if not claimPaused then
				claimAllPlots()
			else
				wait(1)
			end
		end
	end)()
end

-- Function to upgrade all brainrots in player's plot (with anti-detect)
local function upgradeAllBrainrots()
	if not autoUpgradeEnabled then return end

	local playerPlot = LocalPlayer:GetAttribute("Plot")
	if not playerPlot then 
		return 
	end

	local gameFolder = game.Workspace:FindFirstChild("GameFolder")
	if not gameFolder then return end

	local plots = gameFolder:FindFirstChild("Plots")
	if not plots then return end

	local plot = plots:FindFirstChild(tostring(playerPlot))
	if not plot then return end

	local places = plot:FindFirstChild("Places")
	if not places then return end

	local events = ReplicatedStorage:FindFirstChild("Events")
	if not events then return end

	local upgradeEvent = events:FindFirstChild("Upgrade")
	if not upgradeEvent then return end

	local upgradeCount = 0

	for _, place in pairs(places:GetChildren()) do
		if place:IsA("Model") then
			local placeNumber = tonumber(place.Name)
			if placeNumber then
				-- Anti-detect: Random micro-pause before upgrade
				addMicroPause()
				
				local success, result = pcall(function()
					return upgradeEvent:InvokeServer(placeNumber)
				end)

				if success and result then
					upgradeCount = upgradeCount + 1
					-- Anti-detect: Randomized delay between upgrades
					wait(getRandomizedDelay(0.1, 0.4))
				end
			end
		end
	end

	return upgradeCount
end

-- Function to setup auto upgrade with continuous loop
local function setupAutoUpgrade()
	for _, connection in pairs(upgradeConnections) do
		if connection and connection.Disconnect then
			connection:Disconnect()
		end
	end
	upgradeConnections = {}

	if not autoUpgradeEnabled then
		return
	end

	local events = ReplicatedStorage:FindFirstChild("Events")
	if events then
		local animateEvent = events:FindFirstChild("AnimateBrainrot")
		if animateEvent then
			local animConnection = animateEvent.OnClientEvent:Connect(function(brainrot)
				if not autoUpgradeEnabled then return end
				-- Anti-detect: Random delay before upgrading
				wait(getRandomizedDelay(0.2, 0.3))
				upgradeAllBrainrots()
			end)
			table.insert(upgradeConnections, animConnection)
		end
	end

	local loopRunning = true
	table.insert(upgradeConnections, {
		Disconnect = function()
			loopRunning = false
		end
	})

	coroutine.wrap(function()
		while loopRunning and autoUpgradeEnabled do
			upgradeAllBrainrots()
			-- Anti-detect: Randomized upgrade loop delay
			local upgradeDelay = antiDetectRandom:NextNumber(
				ANTI_DETECT.UPGRADE_DELAY_MIN,
				ANTI_DETECT.UPGRADE_DELAY_MAX
			)
			wait(upgradeDelay)
			addIdlePause()
		end
	end)()
end

-- Character respawn handler
local function onCharacterAdded(character)
	local humanoid = character:WaitForChild("Humanoid")
	wait(getRandomizedDelay(0.5, 0.3))

	if not unlimitedJumpEnabled then
		originalJumpPower = humanoid.JumpPower
	else
		setUnlimitedJump(true)
	end

	setupUnlimitedJumping()

	if autoClaimEnabled then
		setupAutoClaimCash()
	end

	if autoUpgradeEnabled then
		setupAutoUpgrade()
	end
end

-- Anti-AFK System
local function setupAntiAFK()
	local VirtualUser = game:GetService("VirtualUser")
	
	LocalPlayer.Idled:Connect(function()
		VirtualUser:CaptureController()
		VirtualUser:ClickButton2(Vector2.new())
	end)
end

-- Initialize Anti-AFK
setupAntiAFK()

-- Initialize
local ScreenGui, JumpToggleButton, JumpToggleCircle, TeleportButton, CelestialToggleButton, CelestialToggleCircle, ClaimToggleButton, ClaimToggleCircle, UpgradeToggleButton, UpgradeToggleCircle, CloseButton, OpenButton, Container = createUI()

-- Jump toggle handler
JumpToggleButton.MouseButton1Click:Connect(function()
	unlimitedJumpEnabled = not unlimitedJumpEnabled
	animateToggle(JumpToggleButton, JumpToggleCircle, unlimitedJumpEnabled, Color3.fromRGB(100, 200, 255))
	setUnlimitedJump(unlimitedJumpEnabled)
end)

-- Teleport button handler
TeleportButton.MouseButton1Click:Connect(function()
	teleportToSpawn()
end)

-- Celestial toggle handler
CelestialToggleButton.MouseButton1Click:Connect(function()
	autoCelestialEnabled = not autoCelestialEnabled
	animateToggle(CelestialToggleButton, CelestialToggleCircle, autoCelestialEnabled, Color3.fromRGB(255, 215, 0))
	setupAutoCelestial()
end)

-- Claim toggle handler
ClaimToggleButton.MouseButton1Click:Connect(function()
	autoClaimEnabled = not autoClaimEnabled
	animateToggle(ClaimToggleButton, ClaimToggleCircle, autoClaimEnabled, Color3.fromRGB(50, 255, 100))
	setupAutoClaimCash()
end)

-- Upgrade toggle handler
UpgradeToggleButton.MouseButton1Click:Connect(function()
	autoUpgradeEnabled = not autoUpgradeEnabled
	animateToggle(UpgradeToggleButton, UpgradeToggleCircle, autoUpgradeEnabled, Color3.fromRGB(147, 112, 219))
	setupAutoUpgrade()
end)

-- Close/Open button handlers
CloseButton.MouseButton1Click:Connect(function()
	Container.Visible = false
	OpenButton.Visible = true
end)

OpenButton.MouseButton1Click:Connect(function()
	Container.Visible = true
	OpenButton.Visible = false
end)

-- Setup character handlers
if LocalPlayer.Character then
	onCharacterAdded(LocalPlayer.Character)
end

LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
setupUnlimitedJumping()
